# Docker Documentation {#docker-documentation}

Docker is a platform for developing, shipping, and running applications in containers. This documentation covers Docker basics and essential concepts.

## Introduction {#introduction}

Docker enables you to separate your applications from your infrastructure, allowing you to deliver software quickly. Docker provides the ability to package and run an application in a loosely isolated environment called a container.

## Getting Started {#getting-started}

[![Docker](/assets/img/docker.svg)](https://www.docker.com/)

### Installation {#installation}

Docker is available for multiple platforms:

- Windows
- macOS
- Linux distributions

Visit the [official Docker website](https://docs.docker.com/get-docker/) to download and install Docker for your platform.

## Basic Concepts {#basic-concepts}

### Images {#images}

**Type definition:**

```ts
interface DockerImage {
  repository: string
  tag: string
  id: string
  created: Date
  size: number
}
```

A Docker image is a read-only template containing:

- Application code
- Runtime environment
- Libraries
- Dependencies
- Configuration files

**Example usage:**

```bash
# Pull an image from Docker Hub
docker pull nginx:latest

# List all images
docker images

# Remove an image
docker rmi nginx:latest
```

### Containers {#containers}

**Type definition:**

```ts
interface DockerContainer {
  id: string
  image: string
  command: string
  created: Date
  status: string
  ports: number[]
}
```

Containers are runnable instances of Docker images. You can:

- Create
- Start
- Stop
- Move
- Delete containers

**Example usage:**

```bash
# Run a container
docker run -d -p 80:80 nginx

# List running containers
docker ps

# Stop a container
docker stop container_id

# Remove a container
docker rm container_id
```

## Dockerfile {#dockerfile}

A Dockerfile is a text document containing instructions to build a Docker image.

**Example Dockerfile:**

```dockerfile
# Use an official Node runtime as the base image
FROM node:18-alpine

# Set the working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy application code
COPY . .

# Expose port
EXPOSE 3000

# Start the application
CMD ["npm", "start"]
```

### Common Dockerfile Instructions {#dockerfile-instructions}

| Instruction | Description                         |
| ----------- | ----------------------------------- |
| FROM        | Sets the base image                 |
| WORKDIR     | Sets working directory              |
| COPY        | Copies files from host to container |
| RUN         | Executes commands during build      |
| EXPOSE      | Documents container ports           |
| CMD         | Sets default command                |
| ENV         | Sets environment variables          |

## Docker Compose {#docker-compose}

Docker Compose is a tool for defining and running multi-container Docker applications.

**Example docker-compose.yml:**

```yaml
version: '3.8'
services:
  web:
    build: .
    ports:
      - '3000:3000'
    environment:
      - NODE_ENV=production
    depends_on:
      - db
  db:
    image: mongodb:latest
    volumes:
      - db-data:/data/db

volumes:
  db-data:
```

### Basic Docker Compose Commands {#compose-commands}

```bash
# Start services
docker-compose up

# Stop services
docker-compose down

# View logs
docker-compose logs

# List services
docker-compose ps
```

## Network {#network}

Docker networking enables containers to communicate with each other and with the outside world.

**Types of networks:**

- bridge: Default network driver
- host: Remove network isolation
- none: Disable networking
- overlay: Connect multiple Docker daemons

**Example commands:**

```bash
# Create a network
docker network create my-network

# List networks
docker network ls

# Connect container to network
docker network connect my-network container_id
```

## Volumes {#volumes}

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.

**Types of volumes:**

- Named volumes
- Bind mounts
- tmpfs mounts (Linux only)

**Example usage:**

```bash
# Create a volume
docker volume create my-volume

# List volumes
docker volume ls

# Run container with volume
docker run -v my-volume:/app/data nginx
```

## Best Practices {#best-practices}

1. **Use official images** as base images when possible
2. **Minimize layers** in Dockerfile to reduce image size
3. **Use .dockerignore** to exclude unnecessary files
4. **Don't run containers as root**
5. **Use multi-stage builds** for smaller production images
6. **Cache dependencies** properly in build process
7. **Set resource limits** for containers

## Troubleshooting {#troubleshooting}

Common commands for debugging:

```bash
# View container logs
docker logs container_id

# Execute command in container
docker exec -it container_id /bin/sh

# View container details
docker inspect container_id

# View resource usage
docker stats
```

::: tip Note
Remember to clean up unused containers and images regularly to save disk space:

```bash
# Remove unused containers
docker container prune

# Remove unused images
docker image prune

# Remove all unused objects
docker system prune
```

:::

## Security Considerations {#security}

1. **Image Security:**

   - Use trusted base images
   - Scan images for vulnerabilities
   - Keep base images updated

2. **Container Security:**

   - Run containers with limited privileges
   - Use security options like `--security-opt`
   - Implement resource limits

3. **Network Security:**
   - Use custom networks for container isolation
   - Limit exposed ports
   - Implement proper access controls

## Additional Resources {#resources}

- [Official Docker Documentation](https://docs.docker.com/)
- [Docker Hub](https://hub.docker.com/)
- [Docker GitHub Repository](https://github.com/docker)
- [Docker Community Forums](https://forums.docker.com/)
